---
title: "Joining Data in R with dplyr"
author: "Alan"
date: "8 de septiembre de 2017"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


## Course Description
This course builds on what you learned in Data Manipulation in R with dplyr by showing you how to combine data sets with dplyr's two table verbs. In the real world, data comes split across many data sets, but dplyr's core functions are designed to work with single tables of data. In this course, you'll learn the best ways to combine data sets into single tables. You'll learn how to augment columns from one data set with columns from another with mutating joins, how to filter one data set against another with filtering joins, and how to sift through data sets with set operations. Along the way, you'll discover the best practices for building data sets and troubleshooting joins with dplyr. Afterwards, youâ€™ll be well on your way to data manipulation mastery!

```{r}

#install.packages("dplyr")
#install.packages("readr")
# install.packages("purrr")
# install.packages("Lahman")

library("dplyr")
library("readr")
library("tibble")
library("purrr")
library("Lahman")

# url <- "http://s3.amazonaws.com/assets.datacamp.com/production/course_1074/datasets/albums.csv"
# url <- "http://s3.amazonaws.com/assets.datacamp.com/production/course_1074/datasets/artists.csv"
# url <- "http://s3.amazonaws.com/assets.datacamp.com/production/course_1074/datasets/bands.csv"
# url <- "http://s3.amazonaws.com/assets.datacamp.com/production/course_1074/datasets/songs.csv"
#url <- "http://s3.amazonaws.com/assets.datacamp.com/production/course_1074/datasets/labels.csv"
# url <- "http://s3.amazonaws.com/assets.datacamp.com/production/course_1074/datasets/tracks.csv"
# url <- "http://s3.amazonaws.com/assets.datacamp.com/production/course_1074/datasets/matches.csv"
# url <- "http://s3.amazonaws.com/assets.datacamp.com/production/course_1074/datasets/aerosmith.csv"
# url <- "http://s3.amazonaws.com/assets.datacamp.com/production/course_1074/datasets/greatest_hits.csv"
# url <- "http://s3.amazonaws.com/assets.datacamp.com/production/course_1074/datasets/live.csv"
# url <- "http://s3.amazonaws.com/assets.datacamp.com/production/course_1074/datasets/definitive.csv"
# url <- "http://s3.amazonaws.com/assets.datacamp.com/production/course_1074/datasets/complete.csv"
# url <- "http://s3.amazonaws.com/assets.datacamp.com/production/course_1074/datasets/soundtrack.csv"
# url <- "http://s3.amazonaws.com/assets.datacamp.com/production/course_1074/datasets/side_one.csv"
# url <- "http://s3.amazonaws.com/assets.datacamp.com/production/course_1074/datasets/side_two.csv"
# url <- "http://s3.amazonaws.com/assets.datacamp.com/production/course_1074/datasets/jimi1.csv"
# url <- "http://s3.amazonaws.com/assets.datacamp.com/production/course_1074/datasets/jimi2.csv"
# url <- "http://s3.amazonaws.com/assets.datacamp.com/production/course_1074/datasets/jimi3.csv"
# url <- "http://s3.amazonaws.com/assets.datacamp.com/production/course_1074/datasets/discography.csv"
# url <- "http://s3.amazonaws.com/assets.datacamp.com/production/course_1074/datasets/hank_charts.csv"
# url <- "http://s3.amazonaws.com/assets.datacamp.com/production/course_1074/datasets/hank_years.csv"
# url <- "http://s3.amazonaws.com/assets.datacamp.com/production/course_1074/datasets/michael1.csv"
# url <- "http://s3.amazonaws.com/assets.datacamp.com/production/course_1074/datasets/michael2.csv"
# url <- "http://s3.amazonaws.com/assets.datacamp.com/production/course_1074/datasets/michael3.csv"
# url <- "http://s3.amazonaws.com/assets.datacamp.com/production/course_1074/datasets/michael4.csv"
# url <- "http://s3.amazonaws.com/assets.datacamp.com/production/course_1074/datasets/michael5.csv"
# url <- "http://s3.amazonaws.com/assets.datacamp.com/production/course_1074/datasets/michael6.csv"
# url <- "http://s3.amazonaws.com/assets.datacamp.com/production/course_1074/datasets/michael7.csv"
# url <- "http://s3.amazonaws.com/assets.datacamp.com/production/course_1074/datasets/michael8.csv"
# url <- "http://s3.amazonaws.com/assets.datacamp.com/production/course_1074/datasets/michael9.csv"
# url <- "http://s3.amazonaws.com/assets.datacamp.com/production/course_1074/datasets/michael10.csv"
# url <- "http://s3.amazonaws.com/assets.datacamp.com/production/course_1074/datasets/seventies.rds"
# url <- "http://s3.amazonaws.com/assets.datacamp.com/production/course_1074/datasets/eighties.rds"
# url <- "http://s3.amazonaws.com/assets.datacamp.com/production/course_1074/datasets/stage_writers.csv"
# url <- "http://s3.amazonaws.com/assets.datacamp.com/production/course_1074/datasets/composers.csv"
# # url <- "http://s3.amazonaws.com/assets.datacamp.com/production/course_1074/datasets/two_songs.csv"
# url <- "http://s3.amazonaws.com/assets.datacamp.com/production/course_1074/datasets/singers.csv"
# url <- "http://s3.amazonaws.com/assets.datacamp.com/production/course_1074/datasets/movie_studios.csv"
# url <- "http://s3.amazonaws.com/assets.datacamp.com/production/course_1074/datasets/elvis_movies.csv"
# url <- "http://s3.amazonaws.com/assets.datacamp.com/production/course_1074/datasets/elvis_songs.csv"
# url <- "http://s3.amazonaws.com/assets.datacamp.com/production/course_1074/datasets/movie_songs.csv"
# url <- "http://s3.amazonaws.com/assets.datacamp.com/production/course_1074/datasets/movie_directors.csv"
 # url <- "http://s3.amazonaws.com/assets.datacamp.com/production/course_1074/datasets/movie_years.csv"
# url <- "http://s3.amazonaws.com/assets.datacamp.com/production/course_1074/datasets/more_bands.csv"
# url <- "http://s3.amazonaws.com/assets.datacamp.com/production/course_1074/datasets/supergroups.csv"
# url <- "http://s3.amazonaws.com/assets.datacamp.com/production/course_1074/datasets/more_artists.csv"
#  url <- "http://s3.amazonaws.com/assets.datacamp.com/production/course_1074/datasets/lahmanNames.rds"
#  
#  
#  
#   download.file(url, "lahmanNames.rds")

albums <- read_csv("albums.csv")
artists <- read_csv("artists.csv")
bands <- read_csv("bands.csv")
songs <- read_csv("songs.csv")
labels <- read_csv("labels.csv")
tracks <- read_csv("tracks.csv")
matches <- read_csv("matches.csv")
aerosmith <- read_csv("aerosmith.csv")
greatest_hits <- read_csv("greatest_hits.csv")
live <- read_csv("live.csv")
definitive <- read_csv("definitive.csv")
complete <- read_csv("complete.csv")
soundtrack <- read_csv("soundtrack.csv")
side_one <- read_csv("side_one.csv")
side_two <- read_csv("side_two.csv")
jimi1 <- read_csv("jimi1.csv")
jimi2 <- read_csv("jimi2.csv")
jimi3 <- read_csv("jimi3.csv")
discography <- read_csv("discography.csv")

jimi <- list("Are You Experienced" = jimi1,
             "Axis: Bold As Love" = jimi2,              
              "Electric Ladyland" = jimi3)

hank_charts <- read_csv("hank_charts.csv")
hank_years <- read_csv("hank_years.csv")

hank0 <- hank_years %>%
  arrange(song) %>%
  select(year) %>%
  bind_cols(hank_charts) %>%
  arrange(year, song)

hank_year <- hank0$year
hank_song <- hank0$song
hank_peak <- hank0$peak

hank <- list(year = hank_year,
             song = hank_song,
             peak = hank_peak)


michael1 <- read_csv("michael1.csv")
michael2 <- read_csv("michael2.csv")
michael3 <- read_csv("michael3.csv")
michael4 <- read_csv("michael4.csv")
michael5 <- read_csv("michael5.csv")
michael6 <- read_csv("michael6.csv")
michael7 <- read_csv("michael7.csv")
michael8 <- read_csv("michael8.csv")
michael9 <- read_csv("michael9.csv")
michael10 <- read_csv("michael10.csv")

michael <- list("Got to Be There" = michael1, "Ben" = michael2,  "Music & Me" = michael3,  
                "Forever, Michael" = michael4, "Off the Wall" = michael5,  "Thriller" = michael6, 
                "Bad" = michael7,  "Dangerous" = michael8, "HIStory" = michael9,  "Invincible" = michael10)

# seventies <- readRDS("seventies.rds")
# 
# eighties <- read_rds("eighties.rds")


stage_songs <- read.csv("stage_songs.csv", row.names = 1, stringsAsFactors = FALSE)
stage_writers <- read.csv("stage_writers.csv", stringsAsFactors = FALSE)

#Chapter 4

shows <- read_csv("shows.csv")
composers <- read_csv("composers.csv")

two_songs <-  read_csv("two_songs.csv")
singers <- read_csv("singers.csv")
movie_studios <- read_csv("movie_studios.csv") 
elvis_movies <- read_csv("elvis_movies.csv")
elvis_songs <- read_csv("elvis_songs.csv")
movie_directors <- read_csv("movie_directors.csv")
movie_songs <- read_csv("movie_songs.csv")
movie_years <- read_csv("movie_years.csv")
more_artists <- read_csv("more_artists.csv")
more_bands <- read_csv("more_bands.csv")
supergroups <- read_csv("supergroups.csv")


#chpater 5

lahmanNames <- readRDS("lahmanNames.rds")



```


## Mutating joins
Mutating joins add new variables to one dataset from another dataset, matching observations across rows in the process. This chapter will explain the various ways you can join datasets together and what happens when you do.

### A basic join

As Garrett mentioned in the video, left_join() is the basic join function in dplyr. You can use it whenever you want to augment a data frame with information from another data frame.

For example, left_join(x, y) joins y to x. The second dataset you specify is joined to the first dataset. Keep that in mind as you go through the course.

For this exercise, the code in the editor sets up a left join but doesn't finish it. It's up to you to complete it.

Instructions
Complete the code to join artists to bands. bands2 should contain all of the information in bands supplemented with information in artists.
Print bands2 to the console to see the result.

```{r}
# Complete the code to join artists to bands
bands2 <- left_join(bands, artists, by = c("first", "last") )

# Examine the results
bands2


```

### A second join

You should always check the output of your joins. Just because a join worked, doesn't mean that it worked as you expected.

For example, the code in the editor joins the same two datasets that you joined in the previous exercise, but it returns a different result. Can you tell what went wrong?

Instructions
The result from the previous exercise, bands2, is loaded in your workspace.

Examine the output from the code provided in the editor. How is it different from bands2?
Fix the code so that the result is identical to bands2.

```{r}
left_join(bands, artists, by = c("first", "last"))

```


### A right join

There is more than one way to execute a left join. Knowing multiple methods will make you a more versatile data scientist, especially as you try to fit joins into pipes created with %>%.

In this exercise, you'll recreate bands2 once more, but this time without using a left_join().

Instructions
Use right_join() to create bands3, a new dataset that contains the same information as bands2.
Use setequal() to check that the datasets are the same.

```{r}
# Finish the code below to recreate bands3 with a right join
bands2 <- left_join(bands, artists, by = c("first", "last"))
bands3 <- right_join(artists, bands, by = c("first", "last"))

# Check that bands3 is equal to bands2
setequal(bands2, bands3)

#Great work! left_join() is equivalent to right_join() with the order of the datasets reversed. Notice that each used the same by argument.

```


### Inner joins and full joins

You may have noticed that some of the songs in songs correspond to some of the albums in albums. Suppose you want a new dataset that contains all of the songs for which you have data from both albums and songs. How would you make it?

The artists and bands datasets also share some information. What if you want to join these two datasets in such a way that you retain all of the information available in both tables, without throwing anything away?

You can think of inner joins as the most strict type of join: they only retain observations that appear in both datasets. In contrast, full joins are the most permissive type of join: they return all of the data that appears in both datasets (often resulting in many missing values).

Recall that, *_join(x, y) joins y to x. The second dataset you specify is joined to the first dataset.

Instructions
Join albums to songs in a way that returns only rows that contain information about both songs and albums.
Join bands to artists to create a single table that contains all of the available data.


```{r}
# Join albums to songs using inner_join()
inner_join(songs, albums, by = "album")

# Join bands to artists using full_join()
full_join(artists, bands, by = c("first", "last"))
```


### Pipes

You can combine dplyr functions together with the pipe operator, %>%, to build up an analysis step-by-step. %>% takes the result of the code that comes before it and "pipes" it into the function that comes after it as the first argument of the function.

So for example, the two pieces of code below do the same thing:

full_join(artists, bands, 
          by = c("first", "last"))

artists %>% 
  full_join(bands, by = c("first", "last"))
Pipes are so efficient for multi-step analysis that you will use them for the remainder of the exercises in this course. (If you need a refresher on the pipe operator, check out Data Manipulation in R with dplyr course!)

Instructions
The code in the editor finds all of the known guitarists in the bands dataset. Rewrite the code to use %>%s instead of multiple function calls. The pipe %>% should be used three times and temp zero times.


```{r}
# Find guitarists in bands dataset (don't change)
temp <- left_join(bands, artists, by = c("first", "last"))
temp <- filter(temp, instrument == "Guitar")
select(temp, first, last, band)

# Reproduce code above using pipes
bands %>% 
  left_join(artists, by = c("first", "last")) %>%
  filter(instrument == "Guitar") %>%
  select(first, last, band)

```

### Practice with pipes and joins

We've created a data frame for you called goal. It's available in your workspace, so go ahead and take a look. Your mission, if you choose to accept it, is to create a dataset that's identical to goal.

Instructions
Examine the goal dataset by printing it to the console.
Write a pipe that uses a full join and an inner join to combine artists, bands, and songs into goal2, a dataset identical to goal.
Use setequal() to check that goal is identical to goal2.
```{r}
#precode
goal <- artists %>%
  full_join(bands, by = c("first", "last")) %>%
  inner_join(songs, by = c("first", "last"))


# Examine the contents of the goal dataset
goal

# Create goal2 using full_join() and inner_join() 
goal2 <- artists %>% 
full_join(bands, by = c("first", "last")) %>%
inner_join(songs, by = c("first", "last"))
  
  
# Check that goal and goal2 are the same
setequal(goal, goal2)


```


### Choose your joins

You're getting the hang of pipes now! They are a very useful way to combine multiple joins to make a single dataset.

Let's craft one more dataset before moving to Chapter 2. One of the most useful ways to combine data is to place all of the values of all of the datasets into a single table.

Instructions
Write a pipe that combines artists, bands, songs, and albums (in that order) into a single table, such that it contains all of the information in the datasets.

```{r}
# Create one table that combines all information
artists %>%
 full_join(bands, by = c("first", "last")) %>%
 full_join(songs, by = c("first", "last")) %>%
 full_join(albums, by = c("album", "band"))

```

## Filtering joins and set operations
Filtering joins and set operations combine information from datasets without adding new variables. Filtering joins filter the observations of one dataset based on whether or not they occur in a second dataset. Set operations use combinations of observations from both datasets to create a new dataset.

### Apply a semi-join

As you saw in the video, semi-joins provide a concise way to filter data from the first dataset based on information in a second dataset.

For example, the code in the editor uses semi_join() to create a data frame of the artists in artists who have written a song in songs.

Instructions
Run the semi_join() command to see its output.
Then fill in the blanks of the right_join(), filter(), and select() calls to create the same result.


```{r}
# View the output of semi_join()
artists %>% 
  semi_join(songs, by = c("first", "last"))

# Create the same result
artists %>% 
  right_join(songs, by = c("first", "last")) %>% 
  filter(!is.na(instrument)) %>% 
  select(first, last, instrument)

```

Exploring with semi-joins

Semi-joins provide a useful way to explore the connections between multiple tables of data.

For example, you can use a semi-join to determine the number of albums in the albums dataset that were made by a band in the bands dataset.

Instructions
For the first pipe, use semi_join() to collect the albums in albums that were made by a band in bands.
For the second pipe, use nrow() to count how many albums were made by a band in the dataset.

```{r}
albums %>% 
  # Collect the albums made by a band
  semi_join(bands, by = "band") %>% 
  # Count the albums made by a band
  nrow()

```


### A more precise way to filter?

We've attempted to rewrite this semi-join as a filter. Will it return the same results?

```{r}
tracks %>% semi_join(
  matches,
  by = c("band", "year", "first")
)

tracks %>% filter(
  (band == "The Beatles" & 
     year == 1964 & first == "Paul") |
    (band == "The Beatles" & 
       year == 1965 & first == "John") |
    (band == "Simon and Garfunkel" & 
       year == 1966 & first == "Paul")
)

```

Apply another anti-join

Anti-joins with anti_join() also provide a great way to diagnose joins that go wrong.

For example, they can help you zero-in on rows that have capitalization or spelling errors in the keys. These things will make your primary and secondary keys appear different to R, even though you know they refer to the same thing.

Instructions
labels describes the record labels of the albums in albums. Compare the spellings of album names in labels with the names in albums. Are any of the album names of labels mis-entered? Use anti_join() to check. Note: Don't forget to mention the by argument.

```{r}
artists
bands

# Return rows of artists that don't have bands info
artists %>% 
  anti_join(bands, by = c("first", "last"))

```

Which filtering join?

Think you have filtering joins down? Let's check.

Which filtering join would you use to determine how many rows in songs match a label in labels?

Instructions
Determine which key joins labels and songs.
Use a filtering join to find the rows of songs that match a row in labels.
Use nrow() to determine how many matches exist between labels and songs.

```{r}
# Determine which key joins labels and songs
labels
songs

# Check your understanding
songs %>% 
  # Find the rows of songs that match a row in labels
  semi_join(labels, by = "album") %>% 
  # Number of matches between labels and songs
  nrow()

```

How many songs are there?

We have loaded two datasets in your workspace, aerosmith and greatest_hits, each of which represents an album from the band Aerosmith. Each row in either of the datasets is a song on that album.

How many unique songs do these two albums contain in total?

Instructions
Use a set operation to create a dataset with every song contained on aerosmith and/or greatest_hits.
Use nrow() to count the total number of songs.

```{r}

aerosmith
greatest_hits


aerosmith %>% 
  # Create the new dataset using a set operation
  union(greatest_hits) %>% 
  # Count the total number of songs
  nrow()

```

Greatest hits

Which songs from Aerosmith made it onto Greatest Hits?

Instructions
Use a set operation to create a dataset containing every track that is in both Aerosmith and Greatest Hits.

```{r}

# Create the new dataset using a set operation
aerosmith %>% 
  intersect(greatest_hits)

```

Live! Bootleg songs

live contains the songs from a third Aerosmith album, Live! Bootleg.

Which songs are on Live! Bootleg but not on Greatest Hits? Notice that the length of songs may be different when they are performed live.

Instructions
Select just the song names from live.
Select just the song names from greatest_hits.
Use a set operation to create a dataset of songs in live that are not in greatest_hits.


```{r}
live
greatest_hits

# Select the song names from live
live_songs <- live %>% select(song)

# Select the song names from greatest_hits
greatest_songs <- greatest_hits %>% select(song)

# Create the new dataset using a set operation
live_songs %>% 
  setdiff(greatest_songs)
```



### Multiple operations

There is no set operation to find rows that appear in one data frame or another, but not both. However, you can accomplish this by combining set operators, as Garrett showed in the video.

Can you think of a combination that would answer the question, "Which songs appear on one of Live! Bootleg or Greatest Hits, but not both?"

Instructions
Select the songs from the live and greatest_hits datasets and call them live_songs and greatest_songs, respectively. Use the select() function to do this.
Combine setdiff(), union(), and intersect() to return all of the songs that are in one of live_songs or greatest_songs, but not both. You will need to use all three functions and save some results along the way (i.e. you won't be able to do this with a single pipe.)

```{r}
# Select songs from live and greatest_hits
live_songs <- live %>%
              select(song)

greatest_songs <- greatest_hits %>%
                  select(song)

# Return the songs that only exist in one dataset

live_songs %>% 
  setdiff(greatest_songs) %>% 
    union(greatest_songs %>%
    setdiff(live_songs))


```

### Apply setequal

definitive and complete contain the songs that appear in competing Led Zeppelin anthologies: The Definitive Collection and The Complete Studio Recordings, respectively.

Both anthologies claim to contain the complete studio recordings of Led Zeppelin, but do the anthologies contain the same exact songs?

Instructions
Use identical() to determine whether definitive and complete contain the same songs in the same order.
Use setequal() to determine whether definitive and complete contain the same songs in any order.
Use setdiff() to see which songs (if any) are in definitive but not complete.
Use setdiff() to see which songs (if any) are in complete but not definitive.

```{r}
# Check if same order: definitive and complete
definitive %>%
  identical(complete)

# Check if any order: definitive and complete
definitive %>%
  setequal(complete)

# Songs in definitive but not complete
definitive %>%
  setdiff(complete)

# Songs in complete but not definitive
complete %>%
  setdiff(definitive)
```


### Apply setequal again

A few exercises ago, you saw that an intersect() is analagous to a semi_join() when two datasets contain the same variables and each variable is used in the key.

Under these conditions, setdiff() is also analagous to one of the filtering joins.

```{r}
# Check if same order: definitive and union of complete and soundtrack
definitive %>% 
  identical(complete %>% union(soundtrack)) 



# Check if any order: definitive and union of complete and soundtrack
definitive %>% 
  setequal(complete %>% union(soundtrack)) 


```

## Assembling data
This chapter will show you how to build datasets from basic elements: vectors, lists, and individual datasets that do not require a join. dplyr contains a set of functions for assembling data that work more intuitively than base R's functions. The chapter will also look at when dplyr does and does not use data type coercion.

### Differences between dplyr and base R

In the video, Garrett mentioned several differences between dplyr's bind_rows() and bind_cols() and base R's rbind() and cbind().

Which of these is true?

bind_rows() and bind_cols() are faster than rbind() and cbind().
bind_rows() and bind_cols() can take a list of data frames as input.
bind_rows() and bind_cols() always return a tibble (a data frame with class tbl_df).
rbind() returns an error when column names do not match across data frames. bind_rows() creates a column for each unique column name and distributes missing values as appropriate.

### Which bind?

side_one and side_two contain tracks from sides one and two, respectively, of Pink Floyd's famous album The Dark Side of the Moon.

Bind these datasets into a single table using a dplyr function. Which type of bind should you use?

Instructions
Examine side_one and side_two by printing them to the console.
Use a bind to combine side_one and side_two into a single dataset.

```{r}

# Examine side_one and side_two
side_one
side_two

# Bind side_one and side_two into a single dataset
side_one %>% 
  bind_rows(side_two)


```

### Bind rows

discography and jimi contain all of the information you need to create an anthology dataset for the band The Jimi Hendrix Experience.

discography contains a data frame of each album by The Jimi Hendrix Experience and the year of the album.

jimi contains a list of data frames of album tracks, one for each album released by The Jimi Hendrix Experience. As Garrett explained in the video, you can pass bind_rows() a list of data frames like jimi to bind together into a single data frame.

Instructions
Examine discography and jimi.
Bind jimi into a single data frame. As you do, save the data frame names as a column named album by specifying the .id argument to bind_rows().
Left join discography to the results to make a complete data frame.

```{r}
# Examine discography and jimi

discography
jimi

jimi %>% 
  # Bind jimi into a single data frame
  bind_rows(.id = "album") %>% 
  # Make a complete data frame
  left_join(discography, by = "album")




```

### Bind columns

Let's make a compilation of Hank Williams' 67 singles. To do this, you can use hank_years and hank_charts:

hank_years contains the name and release year of each of Hank Williams' 67 singles.
hank_charts contains the name of each of Hank Williams' 67 singles as well as the highest position it earned on the Billboard sales charts.
Each dataset contains the same songs, but hank_years is arranged chronologically by year, while hank_charts is arranged alphabetically by song title.

Instructions
Examine hank_years and hank_charts. How should you bind the two datasets?
Use arrange() to reorder hank_years alphabetically by song title.
Select just the year column of the result.
Bind the year column to hank_charts.
arrange() the resulting dataset chronologically by year, then alphabetically by song title within each year.

```{r}

# Examine hank_years and hank_charts
hank_years
hank_charts

hank_years %>% 
  # Reorder hank_years alphabetically by song title
  arrange(song) %>% 
  # Select just the year column
  select(year) %>% 
  # Bind the year column
  bind_cols(hank_charts) %>% 
  # Arrange the finished dataset
  arrange(year, song)

```

### data_frame

Garrett mentioned several advantages of data_frame() over data.frame(). Which of these is not one of them?

True Answers

data_frame always returns a data frame of class tbl_df (if true, assume this is an advantage).
data_frame will not change your column names, even if they are unorthodox.
data_frame never adds row names.
data_frame only recycles length 1 inputs.
data_frame evaluates its arguments lazily and in order.


### Make a data frame

Let's make a Greatest Hits compilation for Hank Williams. hank_year, hank_song, and hank_peak contain the columns of the data frame you made in the last exercise.

Instructions
Use data_frame() to combine hank_year, hank_song, and hank_peak into a data frame that has the column names year, song, and peak; in that order.
Use filter() to extract just the songs where peak equals 1 (i.e. Hank's number one hits.)

```{r}
# Make combined data frame using data_frame()
data_frame(year = hank_year, song = hank_song, peak = hank_peak) %>% 
  # Extract songs where peak equals 1
  filter(hank_peak == 1)
```

### Lists of columns

As a data scientist, you should always be prepared to handle raw data that comes in many different formats.

hank saves Hank Williams' singles in a different way, as a list of vectors. Can you turn hank into the same dataset that you made in the last exercise?

Instructions
Examine the contents of hank.
Use as_data_frame() to convert the hank list into a data frame.
Use filter to extract the number one hits.
```{r}
# Examine the contents of hank
hank

# Convert the hank list into a data frame
hank %>% as_data_frame() %>% 
  # Extract songs where peak equals 1
  filter(peak == 1)
```

### Lists of rows (data frames)

michael contains a list of data frames, one for each album released by Michael Jackson. The code in the editor attempts to bind the data frames into a single data frame and then extract a data frame of the top tracks on each album.

However, the code runs into a problem. The commented line fails because as_data_frame() combines a list of column vectors into a data frame. However, michael is a list of data frames.

Can you fix the code? After all, you have seen something like this before.

Instructions
Examine the contents of michael.
Replace the commented code in the editor with a call to a dplyr function, which should bind the datasets in the list into a single data frame, adding an album column as it does.

```{r}
# Examine the contents of michael
michael

  michael %>%
  bind_rows(.id = "album") %>%
  group_by(album) %>% 
  mutate(rank = min_rank(peak)) %>% 
  filter(rank == 1) %>% 
  select(-rank, -peak)
  
```



### Atomic data types

all statement are correct

Possible Answers
R will coerce logicals and numerics to strings if strings are present.
R will coerce logicals to numerics if numerics are present.
as.character() will coerce factors to their labels as strings if strings are present.
as.numeric() will coerce factors to their levels as numerics if numerics are present.

### dplyr and coercion

How does dplyr extend R's coercion rules? dplyr's two table functions will...

Possible Answers
coerce two factors to a string if the factors have different levels.
coerce two factors to a string if the factors have the same levels in a different order.
return an error instead of coercing logicals, integers, and numerics to a character.



### Determining type

Both seventies and eighties list the top selling albums in the US by year (for the 1970s and the 1980s). However, each stores year as a different data type:

seventies stores year as a factor.
eighties stores year as a character string.
What will be the class of both$year after you run the code below? (Try to answer before running the code!)




## Advanced joining
Now that you have the basics, let's dive deep into the mechanics of joins. This chapter will show you how to spot common join problems, how to join based on multiple or mismatched keys, how to join multiple tables, and how to recreate dplyr's joins with SQL and base R.


### Spot the key

R's data frames can store important information in the row.names attribute. This is not a tidy way to store data, but it does happen quite commonly. If the primary key of your dataset is stored in row.names, you will have trouble joining it to other datasets.

For example, stage_songs contains information about songs that appear in musicals. However, it stores the primary key (song name) in the row.names attribute. As a result, you cannot access the key with a join function.

One way to remedy this problem is to use the function rownames_to_column() from the tibble package. rownames_to_column() returns a copy of a dataset with the row names added to the data as a column.

Instructions
Load the tibble package.
Use rownames_to_column() to add the row names of stage_songs to the data frame as a column named song.
Left join stage_writers to stage_songs.

```{r}
    # Load the tibble package
library("tibble")

stage_songs
stage_writers

stage_songs %>% 
  # Add row names as a column named song
  rownames_to_column(var = "song") %>% 
  # Left join stage_writers to stage_songs
  left_join(stage_writers, by = "song")    




```

### Non-unique keys

shows and composers provide some more information about songs that appear in musicals.

You can join the two datasets by the musical column, which appears in both the datasets. However, you will run into a glitch: the values of musical do not uniquely identify the rows of composers. For example, two rows have the value "The Sound of Music" for musical and two other rows have the value "The King and I".

How many entries (rows) will dplyr create for The Sound of Music if you left join composers to shows by musical?
2


```{r}
shows
composers

composers %>% left_join(shows, by = "musical")


```


### Two non-unique keys

You saw in the last exercise that if a row in the primary dataset contains multiple matches in the secondary dataset, left_join() will duplicate the row once for every match. This is true for all of dplyr's join functions.

Now, let's see how this rule would apply when the primary dataset contains duplicate key values.

show_songs contains songs that appear in the musicals written by the composers. You can join the two by the musical column, but like composers, show_songs has two rows where musical == "The Sound of Music".

How many entries (rows) will exist for The Sound of Music if you left join composers to show_songs by musical?

4

Missing keys

Julie Andrews is a famous singer who performed in The Sound of Music, which is documented in the singers data frame. The two_songs data frame records a couple of songs that she sang during her career.

Unfortunately, when you join the datasets together, something odd happens. According to the result, who sings A Spoonful of Sugar? Why does this happen?

You can avoid this outcome by removing rows that contain NAs in the keys before joining.

Instructions
Take a look at singers and two_songs in the console.

Examine the result of joining singers to two_songs.
Add a filter() call to the pipe to remove NA's from the key column of two_songs before calling inner_join().

```{r}
# Examine the result of joining singers to two_songs
two_songs
singers

two_songs %>% inner_join(singers, by = "movie")

# Remove NA's from key before joining
two_songs %>% 
  filter(!is.na(movie)) %>% 
  inner_join(singers, by = "movie")


```


### A subset of keys

Often the same column name will be used by two datasets to refer to different things. For example, the data frame movie_studios uses name to refer to the name of a movie studio. movie_years uses name to refer to the name of an actor.

You could join these datasets (they describe the same movies), but you wouldn't want to use the name column to do so!

dplyr will ignore duplicate column names if you set the by argument and do not include the duplicated name in the argument. When you do this, dplyr will treat the columns in the normal fashion, but it will add .x and .y to the duplicated names to help you tell the columns apart.

Instructions
Left join movie_studios to movie_years by the movie column. What happens to the duplicated column names?
Use rename() to rename the name column of movie_years to artist, and the name column of movie_studios to studio. As an example, rename(data, new_name = old_name) renames old_name to new_name in data.


```{r}
movie_years
movie_studios

movie_years %>% 
  # Left join movie_studios to movie_years
  left_join(movie_studios, by = "movie") %>% 
  # Rename the columns: artist and studio
  rename(artist = name.x, studio = name.y)
```


Mis-matched key names

Just as the same name can refer to different things in different datasets, different names can refer to the same thing. For example, elvis_movies and elvis_songs both describe movies starring Elvis Presley, but each uses a different column name to describe the name of the movie.

This type of inconsistency can be frustrating when you wish to join data based on the inconsistently named variable.

To make the join, set by to a named vector. The names of the vector will refer to column names in the primary dataset (x). The values of the vector will correspond to the column names in the secondary dataset (y), e.g.

x %>% left_join(y, by = c("x.name1" = "y.name2"))
dplyr will make the join and retain the names in the primary dataset.

Instructions
Identify the column in elvis_songs that corresponds to a column in elvis_movies.
Left join elvis_songs to elvis_movies by this column.
Use rename() to give the result the column names movie, year, and song.

```{r}
# Identify the key column
elvis_songs
elvis_movies

elvis_movies %>% 
  # Left join elvis_songs to elvis_movies by this column
  left_join(elvis_songs, by = c("name" = "movie")) %>% 
  # Rename columns
  rename(movie = name, song = name.y)

```

More mismatched names

Now, you'll practice what you learned in the last exercise.

movie_years and movie_directors both describe movies that feature Frank Sinatra and Bing Crosby. However, each data frame uses different column names to refer to the key variables that connect the datasets.

Can you join the data?

Instructions
Identify the key columns that connect movie_directors to movie_years.
Left join movie_directors to movie_years.
Use select() to arrange the columns in the following order with the following names: year, movie, artist, director, studio.

```{r}
# Identify the key columns
movie_directors
movie_years

movie_years %>% 
  # Left join movie_directors to movie_years
  left_join(movie_directors, by = c("movie" = "name" )) %>%
  rename(artist = name) %>% 
  # Arrange the columns using select()
  select(year, movie, artist, director, studio)
```

Join multiple tables

purrr's reduce() function is very useful for joining together multiple datasets. Let's practice using it with three new datasets.

supergroups lists the members of several "supergroup" bands, which are bands made from the members of other famous bands. more_bands lists the original band membership of many musicians, including those in supergroups. And more_artists lists the instruments that various artists played.

Can you join these datasets into a single, coherent dataset?

Instructions
Load the purrr library.
Place supergroups, more_bands, and more_artists into a list, in that order.
Use reduce() to join together supergroups, more_bands, and more_artists into a dataset that contains all available information about each artist in supergroups (and no others).

```{r}
# Load the purrr library
library("purrr")

supergroups
more_bands
more_artists


# Place supergroups, more_bands, and more_artists into a list
list(supergroups, more_bands, more_artists) %>% 
  # Use reduce to join together the contents of the list
  reduce(left_join, by = c("first", "last"))
```


Filter multiple tables

Nice work! The job of reduce() is to apply a function in an iterative fashion to many datasets. As a result, reduce() works well with all of the dplyr join functions.

For example, you can use reduce() to filter observations with a filtering join.

Instructions
Use reduce() to return just the rows of more_artists that appear in all three datasets.

```{r}

list(more_artists, more_bands, supergroups) %>% 
  # Return rows of more_artists in all three datasets
  reduce(semi_join, by = c("first", "last"))

```


Base R

dplyr joins are also similar to the merge() function in base R.

For example, the code in the editor uses merge() and arrange() to perform a left_join() on bands and artists.

Instructions
Alter the code to perform the join with a dplyr function.
Remove arrange() if your solution does not need it.


```{r}
# Alter the code to perform the join with a dplyr function
merge(bands, artists, by = c("first", "last"), all.x = TRUE) %>%
  arrange(band)

# Alter the code to perform the join with a dplyr function
bands %>%
  left_join(artists, by = c("first", "last")) %>%
  arrange(band)




```


## Case study
You know the ins and outs of two-table verbs with dplyr, but your knowledge is untried! Let's cement what you've learned with a real world application.

### Universal keys?

As Garrett mentioned, the Lahman database contains 26 datasets. Before starting to analyze the data, you'll examine how the datasets are related to each other.

In particular, do any variable names span all of the datasets?

Instructions
Examine lahmanNames by printing it to the console. It is a list of 26 data frames, each of which contains the variable names of one dataset in the Lahman package.
Use purrr's reduce() and a single set operation to return a data frame that contains every variable that appears in all 26 datasets (if any does).

```{r}
# Examine lahmanNames
lahmanNames

# Find variables in common
reduce(lahmanNames, intersect)
```


### Common keys

No variables span all 26 datasets, but several variables span more than one dataset. These variables provide relationships between the various tables in Lahman. Can you find them?

Instructions
Bind the data frames in lahmanNames into a single table that includes a new column called dataframe, which contains the names of the data frames.
Group the result by var.
Tally the number of appearances of each var.
Filter the data to only variables that appear more than once.
Arrange the results so that the most frequently used variables appear before less frequently used variables.


```{r}
lahmanNames %>%  
  # Bind the data frames in lahmanNames
   bind_rows(.id = "dataframe") %>%
  # Group the result by var
  group_by(var) %>%
  # Tally the number of appearances
  tally() %>%
  # Filter the data
  filter(n > 1) %>% 
  # Arrange the results
  arrange(desc(n))

```

### playerID

In the last exercise, you saw that playerID is one of the most widely used keys in the Lahman database. Which datasets use playerID?

Instructions
Bind the data frames in lahmanNames into a single table that includes the column dataframe, which contains the names of the data frames.
Filter the results to just rows that contain playerID.
Extract the dataframe variable.

```{r}
lahmanNames %>% 
    # Bind the data frames
     bind_rows(.id = "dataframe") %>%
    # Filter the results
    filter(var == "playerID") %>% 
    # Extract the dataframe variable
    `$`(dataframe)

```

### Who are the players?

Before we look at salaries, let's begin by ensuring that we have salary information for each player in the database, or at least no systematic holes in our coverage.

To do this we will need a list of every player to compare against salaries. The Master dataset contains all of the players in the database, but it may contain multiple rows for each player.

How should you proceed?

In the video, you saw how to use distinct() to find unique rows for all columns in a table. You can also find unique rows for specific columns using the following syntax:

tbl %>%
  # Find unique rows of columns a,b, and c
  distinct(a, b, c)
Instructions
Use Master to create players, a data frame that contains one row and three columns for each distinct player. The columns should be playerID, nameFirst, and nameLast, in that order.


```{r}
Master

players <- Master %>% 
  # Return one row for each distinct player
  distinct(playerID, nameFirst, nameLast)


```

Great work! players contains a concise list of player IDs and names. Plus we can feel certain that players contains only one row for each distinct player.

### Missing salaries

Now that we know who the players are, let's check our salary coverage. How many players are completely missing salary information?

Instructions
Use a join to find all of the players who do not appear in Salaries.
Then use the dplyr function count() to count how many players do not appear in Salaries.

```{r}

players %>% 
    # Find all players who do not appear in Salaries
    anti_join(Salaries, by = "playerID") %>%
    # Count them
    count()

```


Great work! We are missing the salaries for 13,958 players. No wonder baseball players strike so often!


Unpaid games?

Now that we know there is a huge hole in the salary data, let's see if we can explain it. Is it possible that these players somehow did not play (and hence did not earn a salary)?

We can check with the Appearances data frame. Appearances contains information about every game played in major league baseball. That is, if a player played a game, it would show up as a row in Appearances.

Instructions
Add a join to the pipe to determine how many (if any) unsalaried players played at least one game.


```{r}

players %>% 
  anti_join(Salaries, by = "playerID") %>% 
  # How many unsalaried players appear in Appearances?
  semi_join(Appearances, by = "playerID")  %>% 
  count()

```

Great work! 13,765 players played a game but are missing salary information. Interestingly, 193 players neither played a game nor have a recorded salary.

### How many games?

Perhaps the unsalaried players only played one or two games, and hence did not earn a full salary. Can you determine how many games each of these unsalaried players played?

Instructions
Recalculate the list of players who do not appear in Salaries with the anti_join() function.
Then left join them to Appearances.
Group the data by playerID and calculate the total_games that each player played. This will be the sum() of G_all, ignoring NAs .
Arrange the summarized data in descending order by total_games.


```{r}
players %>% 
  # Find all players who do not appear in Salaries
  anti_join(Salaries, by = "playerID") %>% 
  # Join them to Appearances
  left_join(Appearances, by = "playerID") %>% 
  # Calculate total_games for each player
  group_by(playerID) %>%
  summarise(total_games = sum(G_all, na.rm = TRUE)) %>%
  # Arrange in descending order by total_games
  arrange(desc(total_games))

```

Great work! Many of these players appeared in thousands of games, which rules out our hypothesis that they did not appear in enough games to earn a salary.


### How many at-bats?

Is it possible that the unsalaried players did not actually play in the games that they appeared in? One way to check would be to determine if the players had an at-bat (i.e. batted) in the games that they appeared in.

Instructions
Repeat your process in the previous exercise with Batting instead of Appearances:

Find the unsalaried players.
Left join Batting to the unsalaried players.
Group by player (e.g. playerID).
Calculate the sum of at-bats for each player as total_at_bat; this will be the sum of the AB variable in Batting, ignoring all NAs.
Arrange in descending order of at-bats.


```{r}
players %>%
  # Find unsalaried players
  anti_join(Salaries, by = "playerID") %>%
  # Join Batting to the unsalaried players
  left_join(Batting, by = "playerID") %>%
  # Group by player
  group_by(playerID) %>%
  # Sum at-bats for each player
  summarise(total_at_bat = sum(AB, na.rm= TRUE)) %>%
  # Arrange in descending order
  arrange(desc(total_at_bat))

```

Great work! The unpaid players definitely participated in the games. In fact, you can spot Ty Cobb and Hank Aaron in the top three at-bats. I think it's safe to assume that you are dealing with missing data here and not unsalaried players.

### Hall of fame nominations

As Garrett mentioned, the Hall of Fame is a collection of distinguished baseball players selected by a committee of baseball experts. As with any hall of fame, more players are nominated for membership than are actually admitted.

Let's see how many players have been nominated for the Hall of Fame.

Instructions
Create nominated, a data frame that contains the distinct players (by playerID) that appear in the HallOfFame dataset.
Count the number of players in nominated with count().
Add nameFirst and nameLast values from the Master data frame to nominated. Store the result to a data frame called nominated_full.
```{r}
# Find the distinct players that appear in HallOfFame
nominated <- HallOfFame %>% 
  distinct(playerID)

nominated %>% 
  # Count the number of players in nominated
  count()

nominated_full <- nominated %>% 
  # Join to Master
  left_join(Master, by = "playerID") %>% 
  # Return playerID, nameFirst, nameLast
  select(playerID, nameFirst, nameLast)

nominated_full

```

Great work! There were 1,260 nominees for the Hall of Fame. We now have a dataset of everyone nominated! Let's create a dataset for everyone inducted to the Hall of Fame in the next exercise.


### Hall of fame inductions

In the previous exercise, we saw that 1,239 players were nominated for the hall of fame. Let's now see how many players were admitted to the hall of fame to examine how selective the voting process is.

Instructions
Repeat the process you saw in the last exercise to create inducted, a data frame that contains the distinct players (by playerID) that appear in HallOfFame and have the value inducted == "Y".
Count the number of players in inducted with count().
Add nameFirst and nameLast values from the Master data frame to inducted. Store the result to a data frame called inducted_full.

```{r}
# Find distinct players in HallOfFame with inducted == "Y"
inducted <- HallOfFame %>% 
  filter (inducted == "Y") %>%
  distinct(playerID)  


inducted %>% 
  # Count the number of players in inducted
  count()

inducted_full <- inducted %>% 
  # Join to Master
  left_join(Master, by = "playerID") %>% 
  # Return playerID, nameFirst, nameLast
  select(playerID, nameFirst, nameLast)

inducted_full
```



### Awards

Now that we know who was inducted and who was nominated, let's examine what separates the nominees who were inducted from the nominees who were not.

Let's start with a simple question: Did nominees who were inducted earn more awards than nominees who were not inducted?

We can use AwardsPlayers to answer the question. It lists the playerID's of players who won baseball awards, and it contains one row for each award awarded in major league baseball.

Instructions
tally() the number of awards in AwardsPlayers for each playerID and save the results as nAwards. Note that the resulting column containing the number of awards is called n by default.
Filter nAwards to include the players in inducted and calculate the mean number of awards per player (set na.rm = TRUE). Call the mean number of awards avg_n.
Filter nAwards to include the players in nominated who are not present in inducted and calculate the mean number of awards per player (set na.rm = TRUE). Again, call the mean number of awards avg_n.


```{r}
# Tally the number of awards in AwardsPlayers by playerID
nAwards <- AwardsPlayers %>% 
            count(playerID) 
  

nAwards %>% 
  # Filter to just the players in inducted 
  semi_join(inducted, by = "playerID") %>% 
  # Calculate the mean number of awards per player
    summarise(avg_n = mean(n, na.rm = TRUE))

nAwards %>% 
  # Filter to just the players in nominated 
  semi_join(nominated, by = "playerID") %>% 
  # Filter to players NOT in inducted 
  anti_join(inducted, by = "playerID") %>% 
  # Calculate the mean number of awards per player
  summarise(avg_n = mean(n, na.rm = TRUE))
```
Great work! On Average, inductees had 12.14 - 4.23 = 7.91 more awards than non-inductees.


###Salary

Salary may provide another way to differentiate inductees from non-inductees. Does the maximum salary earned by inductees tend to be greater than the maximum salary earned by nominees who were not inducted?

Instructions
Create notInducted, a dataset that contains the rows of nominated that are not in inducted using a set operation.
Filter Salaries against notInducted to return only the salaries of nominees who were not inducted.
Then calculate the max salary for each player in the results. Call this variable max_salary.
Then in a separate summarize() call, calculate the average of the max salaries. Call this variable avg_salary.
Repeat the process for the players in inducted.

```{r}

# Find the players who are in nominated, but not inducted
notInducted <- nominated %>% 
  setdiff(inducted, by = "playerID")

Salaries %>% 
  # Find the players who are in notInducted
   semi_join(notInducted, by = "playerID") %>% 
  # Calculate the max salary by player
   group_by(playerID) %>% 
   summarise(max_salary = max(salary)) %>% 
  # Calculate the average of the max salaries
  summarise(avg_salary = mean(max_salary))

# Repeat for players who were inducted
Salaries %>% 
  # Find the players who are in notInducted
   semi_join(inducted, by = "playerID") %>% 
  # Calculate the max salary by player
   group_by(playerID) %>% 
   summarise(max_salary = max(salary)) %>% 
  # Calculate the average of the max salaries
  summarise(avg_salary = mean(max_salary))

```

Great work! It turns out that the average salary of players who were inducted was \$6,092,038 - \$5,124,653= $967,385 more per year. We know that we have some missing salary information, but what else could be wrong with this analysis?


### Retirement

One of the rules of the Hall of Fame is that players cannot be nominated until five years after they retire. Is this reflected in our data?

Instructions
Use Appearances to determine the year of the last appearance of each player nominated to the Hall of Fame. Compare it to the year(s) they were nominated to determine whether any players were nominated before they completely retired. You'll want to:

Filter Appearances against nominated to get the information in Appearances for all nominated players.
Use dplyr methods to find the last year played by player. Call this last_year within your summarize() call.
Left join the results to the full HallOfFame dataset.
Use dplyr methods to spot unusual observations.


```{r}
Appearances %>% 
  # Filter Appearances against nominated
  semi_join(nominated, by = "playerID") %>% 
  # Find last year played by player
  group_by(playerID) %>% 
  summarise(last_year = max(yearID)) %>% 
  # Join to full HallOfFame
  left_join(HallOfFame, by = "playerID") %>% 
  # Filter for unusual observations
  filter(last_year>=yearID) 
```



Great work! It looks like quite a few players have been nominated before they retired, but this practice seems much less frequent in recent years.
